// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/*
 * This file is autogenerated by the tool zermio.
 */

#pragma once
/* The `platform.hh` should be created and include the specific platform header which will contain the device
 * addresses.*/
#include "platform.hh"
#include "mmio.hh"
namespace mmio {
namespace uart {

/* UART control register */
union CtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* TX enable */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> tx;
  /* RX enable */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> rx;
  /* RX noise filter enable.If the noise filter is enabled, RX line goes through the 3-taprepetition code. It ignores
   * single IP clock period noise. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> nf;
  /* System loopback enable.If this bit is turned on, any outgoing bits to TX are received through RX.See Block Diagram.
   * Note that the TX line goes 1 if System loopback is enabled. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> slpbk;
  /* Line loopback enable.If this bit is turned on, incoming bits are forwarded to TX for testing purpose.See Block
   * Diagram. Note that the internal design sees RX value as 1 always if lineloopback is enabled. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> llpbk;
  /* If true, parity is enabled in both RX and TX directions. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> parity_en;
  /* If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> parity_odd;
  /* Trigger level for RX break detection. Sets the number of charactertimes the line must be low to detect a break. */
  zermio::BitField<8, 2, zermio::Permissions::ReadWrite> rxblvl;
  /* BAUD clock rate control. */
  zermio::BitField<16, 16, zermio::Permissions::ReadWrite> nco;
  constexpr CtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline CtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART live status register */
union StatusReg {
 private:
  zermio::Register reg_;

 public:
  /* TX buffer is full */
  zermio::BitField<0, 1, zermio::Permissions::Read> txfull;
  /* RX buffer is full */
  zermio::BitField<1, 1, zermio::Permissions::Read> rxfull;
  /* TX FIFO is empty */
  zermio::BitField<2, 1, zermio::Permissions::Read> txempty;
  /* TX FIFO is empty and all bits have been transmitted */
  zermio::BitField<3, 1, zermio::Permissions::Read> txidle;
  /* RX is idle */
  zermio::BitField<4, 1, zermio::Permissions::Read> rxidle;
  /* RX FIFO is empty */
  zermio::BitField<5, 1, zermio::Permissions::Read> rxempty;
  constexpr StatusReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline StatusReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART read data */
union RdataReg {
 private:
  zermio::Register reg_;

 public:
  /* Value */
  zermio::BitField<0, 8, zermio::Permissions::Read> value;
  constexpr RdataReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline RdataReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART write data */
union WdataReg {
 private:
  zermio::Register reg_;

 public:
  /* Value */
  zermio::BitField<0, 8, zermio::Permissions::Write> value;
  constexpr WdataReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline WdataReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART FIFO control register */
union FifoCtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0 */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> rxrst;
  /* TX fifo reset. Write 1 to the register resets TX_FIFO. Read returns 0 */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> txrst;
  /* Trigger level for RX interrupts. If the FIFO depth is greater than or equal tothe setting, it raises rx_watermark
   * interrupt. */
  zermio::BitField<2, 3, zermio::Permissions::ReadWrite> rxilvl;
  /* Trigger level for TX interrupts. If the FIFO depth is less than the setting, itraises tx_watermark interrupt. */
  zermio::BitField<5, 3, zermio::Permissions::ReadWrite> txilvl;
  constexpr FifoCtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline FifoCtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART FIFO status register */
union FifoStatusReg {
 private:
  zermio::Register reg_;

 public:
  /* Current fill level of TX fifo */
  zermio::BitField<0, 8, zermio::Permissions::Read> txlvl;
  /* Current fill level of RX fifo */
  zermio::BitField<16, 8, zermio::Permissions::Read> rxlvl;
  constexpr FifoStatusReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline FifoStatusReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* TX pin override control. Gives direct SW control over TX pin state */
union OvrdReg {
 private:
  zermio::Register reg_;

 public:
  /* Enable TX pin override control */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> txen;
  /* Write to set the value of the TX pin */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> txval;
  constexpr OvrdReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline OvrdReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART oversampled values */
union ValReg {
 private:
  zermio::Register reg_;

 public:
  /* Last 16 oversampled values of RX. Most recent bit is bit 0, oldest 15. */
  zermio::BitField<0, 16, zermio::Permissions::Read> rx;
  constexpr ValReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline ValReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* UART RX timeout control */
union TimeoutCtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* RX timeout value in UART bit times */
  zermio::BitField<0, 24, zermio::Permissions::ReadWrite> val;
  /* Enable RX timeout feature */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> en;
  constexpr TimeoutCtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline TimeoutCtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct Uart {
  CtrlReg ctrl;
  StatusReg status;
  RdataReg rdata;
  WdataReg wdata;
  FifoCtrlReg fifo_ctrl;
  FifoStatusReg fifo_status;
  OvrdReg ovrd;
  ValReg val;
  TimeoutCtrlReg timeout_ctrl;

  constexpr Uart(platform::Uart addr)
      : ctrl(addr + 0x10),
        status(addr + 0x14),
        rdata(addr + 0x18),
        wdata(addr + 0x1c),
        fifo_ctrl(addr + 0x20),
        fifo_status(addr + 0x24),
        ovrd(addr + 0x28),
        val(addr + 0x2c),
        timeout_ctrl(addr + 0x30) {}
};

}  // namespace uart
}  // namespace mmio
