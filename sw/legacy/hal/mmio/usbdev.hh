// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/*
 * This file is autogenerated by the tool zermio.
 */

#pragma once
/* The `platform.hh` should be created and include the specific platform header which will contain the device
 * addresses.*/
#include "platform.hh"
#include "mmio.hh"
namespace mmio {
namespace usbdev {

/* USB Control */
union UsbctrlReg {
 private:
  zermio::Register reg_;

 public:
  /* Set to connect the USB interface (i.e. assert the pullup). */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> enable;
  /* Write a 1 to this bit to instruct usbdev to jump to the LinkResuming state.The write will only have an effect when
   * the device is in the LinkPowered state.Its intention is to handle a resume-from-suspend event after the IP has been
   * powered down. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> resume_link_active;
  /* Device address set by host (this should be copied fromthe Set Device ID SETUP packet).This will be zeroed by the
   * hardware when the link resets. */
  zermio::BitField<16, 7, zermio::Permissions::ReadWrite> device_address;
  constexpr UsbctrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline UsbctrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Enable an endpoint to respond to transactions in the downstream direction.Note that as the default endpoint, endpoint
 * 0 must be enabled in both the IN and OUT directions before enabling the USB interface to connect. */
union EpOutEnableReg {
 private:
  zermio::Register reg_;

 public:
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> enable_0;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> enable_1;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> enable_2;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> enable_3;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> enable_4;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> enable_5;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> enable_6;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> enable_7;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> enable_8;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> enable_9;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> enable_10;
  /* This bit must be set to enable downstream transactions to be received on the endpoint and elicit responses.If the
   * bit is clear, any SETUP or OUT packets sent to the endpoint will be ignored. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> enable_11;
  constexpr EpOutEnableReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline EpOutEnableReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Enable an endpoint to respond to transactions in the upstream direction.Note that as the default endpoint, endpoint 0
 * must be enabled in both the IN and OUT directions before enabling the USB interface to connect. */
union EpInEnableReg {
 private:
  zermio::Register reg_;

 public:
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> enable_0;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> enable_1;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> enable_2;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> enable_3;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> enable_4;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> enable_5;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> enable_6;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> enable_7;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> enable_8;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> enable_9;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> enable_10;
  /* This bit must be set to enable upstream transactions to be received on the endpoint and elicit responses.If the bit
   * is clear then any IN packets sent to the endpoint will be ignored. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> enable_11;
  constexpr EpInEnableReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline EpInEnableReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* USB Status */
union UsbstatReg {
 private:
  zermio::Register reg_;

 public:
  /* Frame index received from host. On an active link, this will increment every milisecond. */
  zermio::BitField<0, 11, zermio::Permissions::Read> frame;
  /* Start of frame not received from host for 4.096 ms and the line is active. */
  zermio::BitField<11, 1, zermio::Permissions::Read> host_lost;
  /* State of USB link, decoded from line. */
  zermio::BitField<12, 3, zermio::Permissions::Read> link_state;
  /* Reflects the state of the sense pin.1 indicates that the host is providing VBUS.Note that this bit always shows the
   * state of the actual pin and does not take account of the override control. */
  zermio::BitField<15, 1, zermio::Permissions::Read> sense;
  /* Number of buffers in the Available Buffer FIFO.These buffers are available for receiving packets. */
  zermio::BitField<16, 4, zermio::Permissions::Read> av_depth;
  /* Available Buffer FIFO is full. */
  zermio::BitField<23, 1, zermio::Permissions::Read> av_full;
  /* Number of buffers in the Received Buffer FIFO.These buffers have packets that have been received andshould be
   * popped from the FIFO and processed. */
  zermio::BitField<24, 4, zermio::Permissions::Read> rx_depth;
  /* Received Buffer FIFO is empty. */
  zermio::BitField<31, 1, zermio::Permissions::Read> rx_empty;
  constexpr UsbstatReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline UsbstatReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Available Buffer FIFO */
union AvbufferReg {
 private:
  zermio::Register reg_;

 public:
  /* This field contains the buffer ID being passed to the USB receive engine.If the Available Buffer FIFO is full, any
   * write operations are discarded. */
  zermio::BitField<0, 5, zermio::Permissions::Write> buffer;
  constexpr AvbufferReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline AvbufferReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Received Buffer FIFO */
union RxfifoReg {
 private:
  zermio::Register reg_;

 public:
  /* This field contains the buffer ID that data was received into.On read the buffer ID is popped from the Received
   * Buffer FIFO and returned to software. */
  zermio::BitField<0, 5, zermio::Permissions::Read> buffer;
  /* This field contains the data length in bytes of the packet written to the buffer. */
  zermio::BitField<8, 7, zermio::Permissions::Read> size;
  /* This bit indicates if the received transaction is of type SETUP (1) or OUT (0). */
  zermio::BitField<19, 1, zermio::Permissions::Read> setup;
  /* This field contains the endpoint ID to which the packet was directed. */
  zermio::BitField<20, 4, zermio::Permissions::Read> ep;
  constexpr RxfifoReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline RxfifoReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Receive SETUP transaction enable */
union RxenableSetupReg {
 private:
  zermio::Register reg_;

 public:
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> setup_0;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> setup_1;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> setup_2;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> setup_3;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> setup_4;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> setup_5;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> setup_6;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> setup_7;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> setup_8;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> setup_9;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> setup_10;
  /* This bit must be set to enable SETUP transactions to bereceived on the endpoint. If the bit is clear then aSETUP
   * packet will be ignored. The bit should be set forcontrol endpoints (and only control endpoints). */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> setup_11;
  constexpr RxenableSetupReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline RxenableSetupReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Receive OUT transaction enable */
union RxenableOutReg {
 private:
  zermio::Register reg_;

 public:
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> out_0;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> out_1;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> out_2;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> out_3;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> out_4;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> out_5;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> out_6;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> out_7;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> out_8;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> out_9;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> out_10;
  /* This bit must be set to enable OUT transactions to be received on the endpoint.If the bit is clear then an OUT
   * request will be responded to with a NAK, if the endpoint is enabled.If set_nak_out for this endpoint is set,
   * hardware will clear this bit whenever an OUT transaction is received on this endpoint.Software must set this bit
   * again to receive the next OUT transaction.Until that happens, hardware will continue to NAK any OUT transaction to
   * this endpoint. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> out_11;
  constexpr RxenableOutReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline RxenableOutReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Set NAK after OUT transactions */
union SetNakOutReg {
 private:
  zermio::Register reg_;

 public:
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> enable_0;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> enable_1;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> enable_2;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> enable_3;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> enable_4;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> enable_5;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> enable_6;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> enable_7;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> enable_8;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> enable_9;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> enable_10;
  /* When this bit is set, hardware will clear this endpoint's rxenable_out bit whenever an OUT transaction is received
   * on this endpoint.This bit should not be changed while the endpoint is active. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> enable_11;
  constexpr SetNakOutReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline SetNakOutReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* IN Transaction Sent */
union InSentReg {
 private:
  zermio::Register reg_;

 public:
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> sent_0;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> sent_1;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> sent_2;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> sent_3;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> sent_4;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> sent_5;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> sent_6;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> sent_7;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> sent_8;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> sent_9;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> sent_10;
  /* This bit will be set when the ACK is received fromthe host to indicate successful packet deliveryas part of an IN
   * transaction. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> sent_11;
  constexpr InSentReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline InSentReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* OUT Endpoint STALL control */
union OutStallReg {
 private:
  zermio::Register reg_;

 public:
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> endpoint_0;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> endpoint_1;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> endpoint_2;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> endpoint_3;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> endpoint_4;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> endpoint_5;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> endpoint_6;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> endpoint_7;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> endpoint_8;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> endpoint_9;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> endpoint_10;
  /* If this bit is set then an OUT transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> endpoint_11;
  constexpr OutStallReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline OutStallReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* IN Endpoint STALL control */
union InStallReg {
 private:
  zermio::Register reg_;

 public:
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> endpoint_0;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> endpoint_1;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> endpoint_2;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> endpoint_3;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> endpoint_4;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> endpoint_5;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> endpoint_6;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> endpoint_7;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> endpoint_8;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> endpoint_9;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> endpoint_10;
  /* If this bit is set then an IN transaction to this endpoint will elicit a STALL handshake, when a non-isochronous
   * endpoint is enabled.If the configuration has both STALL and NAK enabled, the STALL handshake will take
   * priority.Note that SETUP transactions are always either accepted or ignored.For endpoints that accept SETUP
   * transactions, a SETUP packet will clear the STALL flag on endpoints for both the IN and OUT directions. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> endpoint_11;
  constexpr InStallReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline InStallReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin0Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin0Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin0Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin1Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin1Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin1Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin2Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin2Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin2Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin3Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin3Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin3Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin4Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin4Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin4Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin5Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin5Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin5Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin6Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin6Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin6Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin7Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin7Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin7Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin8Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin8Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin8Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin9Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin9Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin9Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin10Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin10Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin10Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Configure IN Transaction */
union Configin11Reg {
 private:
  zermio::Register reg_;

 public:
  /* The buffer ID containing the data to send when an IN transaction is received on the endpoint. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> buffer;
  /* The number of bytes to send from the buffer.If this is 0 then a CRC only packet is sent.If this is greater than 64
   * then 64 bytes are sent. */
  zermio::BitField<8, 7, zermio::Permissions::ReadWrite> size;
  /* This bit indicates a pending transaction was canceled by the hardware.The bit is set when the rdy bit is cleared by
   * hardware because of aSETUP packet being received or a link reset being detected.The bit remains set until cleared
   * by being written with a 1. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> pend;
  /* This bit should be set to indicate the buffer is ready for sending.It will be cleared when the ACK is received
   * indicating the host has accepted the data.This bit will also be cleared if an enabled SETUP transaction is received
   * on the endpoint.This allows use of the IN channel for transfer of SETUP information.The original buffer must be
   * resubmitted after the SETUP sequence is complete.A link reset also clears the bit.In either of the cases where the
   * hardware cancels the transaction it will also set the pend bit. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> rdy;
  constexpr Configin11Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Configin11Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* OUT Endpoint isochronous setting */
union OutIsoReg {
 private:
  zermio::Register reg_;

 public:
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> iso_0;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> iso_1;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> iso_2;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> iso_3;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> iso_4;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> iso_5;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> iso_6;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> iso_7;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> iso_8;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> iso_9;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> iso_10;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be sent
   * for an OUT transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not take
   * effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> iso_11;
  constexpr OutIsoReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline OutIsoReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* IN Endpoint isochronous setting */
union InIsoReg {
 private:
  zermio::Register reg_;

 public:
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> iso_0;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> iso_1;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> iso_2;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> iso_3;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> iso_4;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> iso_5;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> iso_6;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> iso_7;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> iso_8;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<9, 1, zermio::Permissions::ReadWrite> iso_9;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<10, 1, zermio::Permissions::ReadWrite> iso_10;
  /* If this bit is set then the endpoint will be treated as an isochronous endpoint.No handshake packet will be
   * expected for an IN transaction.Note that if a rxenable_setup is set for this endpoint's number, this bit will not
   * take effect.Control endpoint configuration trumps isochronous endpoint configuration. */
  zermio::BitField<11, 1, zermio::Permissions::ReadWrite> iso_11;
  constexpr InIsoReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline InIsoReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Clear the data toggle flag */
union DataToggleClearReg {
 private:
  zermio::Register reg_;

 public:
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<0, 1, zermio::Permissions::Write> clear_0;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<1, 1, zermio::Permissions::Write> clear_1;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<2, 1, zermio::Permissions::Write> clear_2;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<3, 1, zermio::Permissions::Write> clear_3;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<4, 1, zermio::Permissions::Write> clear_4;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<5, 1, zermio::Permissions::Write> clear_5;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<6, 1, zermio::Permissions::Write> clear_6;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<7, 1, zermio::Permissions::Write> clear_7;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<8, 1, zermio::Permissions::Write> clear_8;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<9, 1, zermio::Permissions::Write> clear_9;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<10, 1, zermio::Permissions::Write> clear_10;
  /* Writing 1 to this bit will clear the data toggle bit for this endpoint to Data0 in both IN and OUT directions.The
   * register must no be written again within 200 ns. */
  zermio::BitField<11, 1, zermio::Permissions::Write> clear_11;
  constexpr DataToggleClearReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline DataToggleClearReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* USB PHY pins sense.This register can be used to read out the state of the USB device inputs and outputs from
 * software.This is designed to be used for debugging purposes or during chip testing. */
union PhyPinsSenseReg {
 private:
  zermio::Register reg_;

 public:
  /* USB D+ input. */
  zermio::BitField<0, 1, zermio::Permissions::Read> rx_dp_i;
  /* USB D- input. */
  zermio::BitField<1, 1, zermio::Permissions::Read> rx_dn_i;
  /* USB data input from an external differential receiver, if available. */
  zermio::BitField<2, 1, zermio::Permissions::Read> rx_d_i;
  /* USB transmit D+ output (readback). */
  zermio::BitField<8, 1, zermio::Permissions::Read> tx_dp_o;
  /* USB transmit D- output (readback). */
  zermio::BitField<9, 1, zermio::Permissions::Read> tx_dn_o;
  /* USB transmit data value (readback). */
  zermio::BitField<10, 1, zermio::Permissions::Read> tx_d_o;
  /* USB single-ended zero output (readback). */
  zermio::BitField<11, 1, zermio::Permissions::Read> tx_se0_o;
  /* USB OE output (readback). */
  zermio::BitField<12, 1, zermio::Permissions::Read> tx_oe_o;
  /* USB power sense signal. */
  zermio::BitField<16, 1, zermio::Permissions::Read> pwr_sense;
  constexpr PhyPinsSenseReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline PhyPinsSenseReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* USB PHY pins drive.This register can be used to control the USB device inputs and outputs from software.This is
 * designed to be used for debugging purposes or during chip testing. */
union PhyPinsDriveReg {
 private:
  zermio::Register reg_;

 public:
  /* USB transmit D+ output, used with dn_o. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> dp_o;
  /* USB transmit D- output, used with dp_o. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> dn_o;
  /* USB transmit data output, encoding K and J when se0_o is 0. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> d_o;
  /* USB single-ended zero output. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> se0_o;
  /* USB OE output. */
  zermio::BitField<4, 1, zermio::Permissions::ReadWrite> oe_o;
  /* Enable differential receiver. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> rx_enable_o;
  /* USB D+ pullup enable output. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> dp_pullup_en_o;
  /* USB D- pullup enable output. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> dn_pullup_en_o;
  /* 0: Outputs are controlled by the hardware block.1: Outputs are controlled with this register. */
  zermio::BitField<16, 1, zermio::Permissions::ReadWrite> en;
  constexpr PhyPinsDriveReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline PhyPinsDriveReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* USB PHY Configuration */
union PhyConfigReg {
 private:
  zermio::Register reg_;

 public:
  /* Detect received K and J symbols from the usb_rx_d signal, which must be driven from an external differential
   * receiver.If 1, make use of the usb_rx_d input.If 0, the usb_rx_d input is ignored and the usb_rx_dp and usb_rx_dn
   * pair are used to detect K and J (useful for some environments, but will be unlikely to pass full USB
   * compliance).Regardless of the state of this field usb_rx_dp and usb_rx_dn are always used to detect SE0.This bit
   * also feeds the rx_enable pin, activating the receiver when the device is not suspended. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> use_diff_rcvr;
  /* If 1, select the d and se0 TX interface.If 0, select the dp and dn TX interface.This directly controls the output
   * pin of the same name.It is intended to be used to enable the use of a variety of external transceivers, to select
   * an encoding that matches the transceiver. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> tx_use_d_se0;
  /* Recognize a single SE0 bit as an end of packet, otherwise two successive bits are required. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> eop_single_bit;
  /* Flip the D+/D- pins.Particularly useful if D+/D- are mapped to SBU1/SBU2 pins of USB-C. */
  zermio::BitField<5, 1, zermio::Permissions::ReadWrite> pinflip;
  /* 0: Enable reference signal generation for clock synchronization, 1: disable it by forcing the associated signals to
   * zero. */
  zermio::BitField<6, 1, zermio::Permissions::ReadWrite> usb_ref_disable;
  /* Disable (0) or enable (1) oscillator test mode.If enabled, the device constantly transmits a J/K pattern, which is
   * useful for testing the USB clock.Note that while in oscillator test mode, the device no longer receives SOFs and
   * consequently does not generate the reference signal for clock synchronization.The clock might drift off. */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> tx_osc_test_mode;
  constexpr PhyConfigReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline PhyConfigReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* USB wake module control for suspend / resume */
union WakeControlReg {
 private:
  zermio::Register reg_;

 public:
  /* Suspend request to the wake detection module.Trigger the wake detection module to begin monitoring for
   * wake-from-suspend events.When written with a 1, the wake detection module will activate.Activation may not happen
   * immediately, and its status can be verified by checking wake_events.module_active. */
  zermio::BitField<0, 1, zermio::Permissions::Write> suspend_req;
  /* Wake acknowledgement.Signal to the wake detection module that it may release control of the pull-ups back to the
   * main block and return to an inactive state.The release back to normal state may not happen immediately.The status
   * can be confirmed via wake_events.module_active.Note that this bit can also be used without powering down, such as
   * when usbdev detects resume signaling before transitions to low power states have begun. */
  zermio::BitField<1, 1, zermio::Permissions::Write> wake_ack;
  constexpr WakeControlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline WakeControlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* USB wake module events and debug */
union WakeEventsReg {
 private:
  zermio::Register reg_;

 public:
  /* USB aon wake module is active, monitoring events and controlling the pull-ups. */
  zermio::BitField<0, 1, zermio::Permissions::Read> module_active;
  /* USB aon wake module detected VBUS was interrupted while monitoring events. */
  zermio::BitField<8, 1, zermio::Permissions::Read> disconnected;
  /* USB aon wake module detected a bus reset while monitoring events. */
  zermio::BitField<9, 1, zermio::Permissions::Read> bus_reset;
  constexpr WakeEventsReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline WakeEventsReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct Usbdev {
  UsbctrlReg usbctrl;
  EpOutEnableReg ep_out_enable;
  EpInEnableReg ep_in_enable;
  UsbstatReg usbstat;
  AvbufferReg avbuffer;
  RxfifoReg rxfifo;
  RxenableSetupReg rxenable_setup;
  RxenableOutReg rxenable_out;
  SetNakOutReg set_nak_out;
  InSentReg in_sent;
  OutStallReg out_stall;
  InStallReg in_stall;
  Configin0Reg configin_0;
  Configin1Reg configin_1;
  Configin2Reg configin_2;
  Configin3Reg configin_3;
  Configin4Reg configin_4;
  Configin5Reg configin_5;
  Configin6Reg configin_6;
  Configin7Reg configin_7;
  Configin8Reg configin_8;
  Configin9Reg configin_9;
  Configin10Reg configin_10;
  Configin11Reg configin_11;
  OutIsoReg out_iso;
  InIsoReg in_iso;
  DataToggleClearReg data_toggle_clear;
  PhyPinsSenseReg phy_pins_sense;
  PhyPinsDriveReg phy_pins_drive;
  PhyConfigReg phy_config;
  WakeControlReg wake_control;
  WakeEventsReg wake_events;

  constexpr Usbdev(platform::Usbdev addr)
      : usbctrl(addr + 0x40),
        ep_out_enable(addr + 0x44),
        ep_in_enable(addr + 0x74),
        usbstat(addr + 0xa4),
        avbuffer(addr + 0xa8),
        rxfifo(addr + 0xac),
        rxenable_setup(addr + 0xb0),
        rxenable_out(addr + 0xe0),
        set_nak_out(addr + 0x110),
        in_sent(addr + 0x140),
        out_stall(addr + 0x170),
        in_stall(addr + 0x1a0),
        configin_0(addr + 0x1d0),
        configin_1(addr + 0x1d4),
        configin_2(addr + 0x1d8),
        configin_3(addr + 0x1dc),
        configin_4(addr + 0x1e0),
        configin_5(addr + 0x1e4),
        configin_6(addr + 0x1e8),
        configin_7(addr + 0x1ec),
        configin_8(addr + 0x1f0),
        configin_9(addr + 0x1f4),
        configin_10(addr + 0x1f8),
        configin_11(addr + 0x1fc),
        out_iso(addr + 0x200),
        in_iso(addr + 0x230),
        data_toggle_clear(addr + 0x260),
        phy_pins_sense(addr + 0x290),
        phy_pins_drive(addr + 0x294),
        phy_config(addr + 0x298),
        wake_control(addr + 0x29c),
        wake_events(addr + 0x2a0) {}
};

}  // namespace usbdev
}  // namespace mmio
