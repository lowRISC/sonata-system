// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/*
 * This file is autogenerated by the tool zermio.
 */

#pragma once
/* The `platform.hh` should be created and include the specific platform header which will contain the device
 * addresses.*/
#include "platform.hh"
#include "mmio.hh"
namespace mmio {
namespace spi {

/* Configuration register */
union CfgReg {
 private:
  zermio::Register reg_;

 public:
  /* The polarity of the spi_clk signal. When CPOL is 0 clock is low when idle and the leading edge is positive. When
   * CPOL is 1 clock is high when idle and the leading edge is negative */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> cpol;
  /* The phase of the spi_clk signal. When CPHA is 0 data is sampled on the leading edge and changes on the trailing
   * edge. The first data bit is immediately available before the first leading edge of the clock when transmission
   * begins. When CPHA is 1 data is sampled on the trailing edge and change on the leading edge. */
  zermio::BitField<30, 1, zermio::Permissions::ReadWrite> cpha;
  /* When set the most significant bit (MSB) is the first bit sent and received with each byte */
  zermio::BitField<29, 1, zermio::Permissions::ReadWrite> msb_first;
  /* The length of a half period (i.e. positive edge to negative edge) of the SPI clock, measured in system clock cycles
   * reduced by 1. At the standard Sonata 50 MHz system clock a value of 0 gives a 25 MHz SPI clock, a value of 1 gives
   * a 12.5 MHz SPI clock, a value of 2 gives a 8.33 MHz SPI clock and so on. */
  zermio::BitField<16, 13, zermio::Permissions::ReadWrite> half_clk_period;
  constexpr CfgReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline CfgReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* SPI control register */
union CtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* Software reset perfomed when written 1. */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> sw_reset;
  /* The watermark level for the receive FIFO, depending on the value the interrupt will trigger at different points:\n
                          0: 1 or more items in the FIFO\n
                          1: 2 or more items in the FIFO\n
                          2: 4 or more items in the FIFO\n
                          3: 8 or more items in the FIFO\n
                          4: 16 or more items in the FIFO\n
                          5: 32 or more items in the FIFO\n
                          6: 56 or more items in the FIFO\n */
  zermio::BitField<8, 4, zermio::Permissions::ReadWrite> rx_watermark;
  /* The watermark level for the transmit FIFO, depending on the value the interrupt will trigger at different points:\n
                          0: 1 or more items in the FIFO\n
                          1: 2 or more items in the FIFO\n
                          2: 4 or more items in the FIFO\n
                          3: 8 or more items in the FIFO\n
                          4: 16 or more items in the FIFO\n */
  zermio::BitField<4, 4, zermio::Permissions::ReadWrite> tx_watermark;
  /* When set incoming bits are written to the receive FIFO. When clear incoming bits are ignored. */
  zermio::BitField<3, 1, zermio::Permissions::ReadWrite> rx_enable;
  /* When set bytes from the transmit FIFO are sent. When clear the state of the outgoing spi_cipo is undefined whilst
   * the SPI clock is running. */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> tx_enable;
  /* Write 1 to clear the receive FIFO. */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> rx_clear;
  /* Write 1 to clear the transmit FIFO. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> tx_clear;
  constexpr CtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline CtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* SPI Status Register */
union StatusReg {
 private:
  zermio::Register reg_;

 public:
  /* When set the SPI block is idle and can accept a new start command. */
  zermio::BitField<18, 1, zermio::Permissions::Read> idle;
  /* When set the receive FIFO is empty and any data read from it will be undefined. */
  zermio::BitField<17, 1, zermio::Permissions::Read> rx_fifo_empty;
  /* When set the transmit FIFO is full and any data written to it will be ignored. */
  zermio::BitField<16, 1, zermio::Permissions::Read> tx_fifo_full;
  /* Number of items in the receive FIFO */
  zermio::BitField<8, 8, zermio::Permissions::Read> rx_fifo_level;
  /* Number of items in the transmit FIFO */
  zermio::BitField<0, 8, zermio::Permissions::Read> tx_fifo_level;
  constexpr StatusReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline StatusReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* When written begins an SPI operation. Writes are ignored when the SPI block is active. */
union StartReg {
 private:
  zermio::Register reg_;

 public:
  /* Number of bytes to receive/transmit in the SPI operation */
  zermio::BitField<0, 11, zermio::Permissions::Write> byte_count;
  constexpr StartReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline StartReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Data from the receive FIFO */
union RxFifoReg {
 private:
  zermio::Register reg_;

 public:
  /* Byte popped from the FIFO. */
  zermio::BitField<0, 8, zermio::Permissions::Read> data;
  constexpr RxFifoReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline RxFifoReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Bytes written here are pushed to the transmit FIFO */
union TxFifoReg {
 private:
  zermio::Register reg_;

 public:
  /* Byte to be push to the FIFO. */
  zermio::BitField<0, 8, zermio::Permissions::Write> data;
  constexpr TxFifoReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline TxFifoReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Bytes written here are pushed to the transmit FIFO */
union InfoReg {
 private:
  zermio::Register reg_;

 public:
  /* Maximum number of items in the receive FIFO. */
  zermio::BitField<8, 8, zermio::Permissions::Read> rx_fifo_depth;
  /* Maximum number of items in the transmit FIFO. */
  zermio::BitField<0, 8, zermio::Permissions::Read> tx_fifo_depth;
  constexpr InfoReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline InfoReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Specifies which peripherals are selected for transmit/receive operations. An operation may select multiple
 * peripherals simultaneously but this functionality shall be used only for transmit operations. This register shall be
 * changed only when the SPI controller is idle, not whilst a transmit/receive operation may be in progress. */
union CsReg {
 private:
  zermio::Register reg_;

 public:
  /* These bits are zero when the corresponding peripheral is selected for transmit/receive operations. */
  zermio::BitField<0, 5, zermio::Permissions::ReadWrite> cs;
  constexpr CsReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline CsReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct Spi {
  CfgReg cfg;
  CtrlReg ctrl;
  StatusReg status;
  StartReg start;
  RxFifoReg rx_fifo;
  TxFifoReg tx_fifo;
  InfoReg info;
  CsReg cs;

  constexpr Spi(platform::Spi addr)
      : cfg(addr + 0xc),
        ctrl(addr + 0x10),
        status(addr + 0x14),
        start(addr + 0x18),
        rx_fifo(addr + 0x1c),
        tx_fifo(addr + 0x20),
        info(addr + 0x24),
        cs(addr + 0x28) {}
};

}  // namespace spi
}  // namespace mmio
