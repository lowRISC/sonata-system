// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/*
 * This file is autogenerated by the tool zermio.
 */

#pragma once
/* The `platform.hh` should be created and include the specific platform header which will contain the device
 * addresses.*/
#include "platform.hh"
#include "mmio.hh"
namespace mmio {
namespace i2c {

/* I2C Control Register */
union CtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* Enable Host I2C functionality */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> enablehost;
  /* Enable Target I2C functionality */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> enabletarget;
  /* Enable I2C line loopback testIf line loopback is enabled, the internal design sees ACQ and RX data as "1" */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> llpbk;
  constexpr CtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline CtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C Live Status Register */
union StatusReg {
 private:
  zermio::Register reg_;

 public:
  /* FMT FIFO is full */
  zermio::BitField<0, 1, zermio::Permissions::Read> fmtfull;
  /* RX FIFO is full */
  zermio::BitField<1, 1, zermio::Permissions::Read> rxfull;
  /* FMT FIFO is empty */
  zermio::BitField<2, 1, zermio::Permissions::Read> fmtempty;
  /* RX FIFO is empty */
  zermio::BitField<5, 1, zermio::Permissions::Read> rxempty;
  /* Host functionality is idle. No Host transaction is in progress */
  zermio::BitField<3, 1, zermio::Permissions::Read> hostidle;
  /* Target functionality is idle. No Target transaction is in progress */
  zermio::BitField<4, 1, zermio::Permissions::Read> targetidle;
  /* TX FIFO is full */
  zermio::BitField<6, 1, zermio::Permissions::Read> txfull;
  /* ACQ FIFO is full */
  zermio::BitField<7, 1, zermio::Permissions::Read> acqfull;
  /* TX FIFO is empty */
  zermio::BitField<8, 1, zermio::Permissions::Read> txempty;
  /* ACQ FIFO is empty */
  zermio::BitField<9, 1, zermio::Permissions::Read> acqempty;
  constexpr StatusReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline StatusReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C Read Data */
union RdataReg {
 private:
  zermio::Register reg_;

 public:
  /* Value */
  zermio::BitField<0, 8, zermio::Permissions::Read> value;
  constexpr RdataReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline RdataReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C Format Data */
union FdataReg {
 private:
  zermio::Register reg_;

 public:
  /* Format Byte. Directly transmitted if no flags are set. */
  zermio::BitField<0, 8, zermio::Permissions::Write> fbyte;
  /* Issue a START condition before transmitting BYTE. */
  zermio::BitField<8, 1, zermio::Permissions::Write> start;
  /* Issue a STOP condition after this operation */
  zermio::BitField<9, 1, zermio::Permissions::Write> stop;
  /* Read BYTE bytes from I2C. (256 if BYTE==0) */
  zermio::BitField<10, 1, zermio::Permissions::Write> read;
  /* Do not NACK the last byte read, let the read operation continue */
  zermio::BitField<11, 1, zermio::Permissions::Write> rcont;
  /* Do not signal an exception if the current byte is not ACK'd */
  zermio::BitField<12, 1, zermio::Permissions::Write> nakok;
  constexpr FdataReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline FdataReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C FIFO control register */
union FifoCtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0 */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> rxrst;
  /* FMT fifo reset. Write 1 to the register resets FMT_FIFO. Read returns 0 */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> fmtrst;
  /* Trigger level for RX interrupts. If the FIFO depth exceedsthis setting, it raises rx_threshold interrupt. */
  zermio::BitField<2, 3, zermio::Permissions::ReadWrite> rxilvl;
  /* Trigger level for FMT interrupts. If the FIFO depth falls belowthis setting, it raises fmt_threshold interrupt. */
  zermio::BitField<5, 2, zermio::Permissions::ReadWrite> fmtilvl;
  /* ACQ FIFO reset. Write 1 to the register resets it. Read returns 0 */
  zermio::BitField<7, 1, zermio::Permissions::ReadWrite> acqrst;
  /* TX FIFO reset. Write 1 to the register resets it. Read returns 0 */
  zermio::BitField<8, 1, zermio::Permissions::ReadWrite> txrst;
  constexpr FifoCtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline FifoCtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C FIFO status register */
union FifoStatusReg {
 private:
  zermio::Register reg_;

 public:
  /* Current fill level of FMT fifo */
  zermio::BitField<0, 7, zermio::Permissions::Read> fmtlvl;
  /* Current fill level of RX fifo */
  zermio::BitField<16, 7, zermio::Permissions::Read> rxlvl;
  /* Current fill level of TX fifo */
  zermio::BitField<8, 7, zermio::Permissions::Read> txlvl;
  /* Current fill level of ACQ fifo */
  zermio::BitField<24, 7, zermio::Permissions::Read> acqlvl;
  constexpr FifoStatusReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline FifoStatusReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C Override Control Register */
union OvrdReg {
 private:
  zermio::Register reg_;

 public:
  /* Override the SDA and SCL TX signals. */
  zermio::BitField<0, 1, zermio::Permissions::ReadWrite> txovrden;
  /* Value for SCL Override. Set to 0 to drive TX Low, and set to 1 for high-Z */
  zermio::BitField<1, 1, zermio::Permissions::ReadWrite> sclval;
  /* Value for SDA Override. Set to 0 to drive TX Low, and set to 1 for high-Z */
  zermio::BitField<2, 1, zermio::Permissions::ReadWrite> sdaval;
  constexpr OvrdReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline OvrdReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Oversampled RX values */
union ValReg {
 private:
  zermio::Register reg_;

 public:
  /* Last 16 oversampled values of SCL. Most recent bit is bit 0, oldest 15. */
  zermio::BitField<0, 16, zermio::Permissions::Read> scl_rx;
  /* Last 16 oversampled values of SDA. Most recent bit is bit 16, oldest 31. */
  zermio::BitField<16, 16, zermio::Permissions::Read> sda_rx;
  constexpr ValReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline ValReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units
 * of the input clock period.These must be greater than 2 in order for the change in SCL to propagate to the input of
 * the FSM so that acknowledgements are detected correctly. */
union Timing0Reg {
 private:
  zermio::Register reg_;

 public:
  /* The actual time to hold SCL high in a given pulse: in host mode, when there is no stretching this value is 3 cycles
   * longer as tracked in issue #18962 */
  zermio::BitField<0, 16, zermio::Permissions::ReadWrite> thigh;
  /* The actual time to hold SCL low between any two SCL pulses */
  zermio::BitField<16, 16, zermio::Permissions::ReadWrite> tlow;
  constexpr Timing0Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Timing0Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units
 * of the input clock period. */
union Timing1Reg {
 private:
  zermio::Register reg_;

 public:
  /* The nominal rise time to anticipate for the bus (depends on capacitance) */
  zermio::BitField<0, 16, zermio::Permissions::ReadWrite> t_r;
  /* The nominal fall time to anticipate for the bus (influences SDA hold times): this is currently counted twice in
   * host mode as tracked in issue #18958 */
  zermio::BitField<16, 16, zermio::Permissions::ReadWrite> t_f;
  constexpr Timing1Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Timing1Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units
 * of the input clock period. */
union Timing2Reg {
 private:
  zermio::Register reg_;

 public:
  /* Actual setup time for repeated start signals */
  zermio::BitField<0, 16, zermio::Permissions::ReadWrite> tsu_sta;
  /* Actual hold time for start signals */
  zermio::BitField<16, 16, zermio::Permissions::ReadWrite> thd_sta;
  constexpr Timing2Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Timing2Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units
 * of the input clock period. */
union Timing3Reg {
 private:
  zermio::Register reg_;

 public:
  /* Actual setup time for data (or ack) bits */
  zermio::BitField<0, 16, zermio::Permissions::ReadWrite> tsu_dat;
  /* Actual hold time for data (or ack) bits(Note, where required, the parameters TVD_DAT is taken to be THD_DAT+T_F) */
  zermio::BitField<16, 16, zermio::Permissions::ReadWrite> thd_dat;
  constexpr Timing3Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Timing3Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units
 * of the input clock period. */
union Timing4Reg {
 private:
  zermio::Register reg_;

 public:
  /* Actual setup time for stop signals */
  zermio::BitField<0, 16, zermio::Permissions::ReadWrite> tsu_sto;
  /* Actual time between each STOP signal and the following START signal */
  zermio::BitField<16, 16, zermio::Permissions::ReadWrite> t_buf;
  constexpr Timing4Reg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline Timing4Reg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C clock stretching timeout control */
union TimeoutCtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* Clock stretching timeout value (in units of input clock frequency) */
  zermio::BitField<0, 31, zermio::Permissions::ReadWrite> val;
  /* Enable timeout feature */
  zermio::BitField<31, 1, zermio::Permissions::ReadWrite> en;
  constexpr TimeoutCtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline TimeoutCtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C target address and mask pairs */
union TargetIdReg {
 private:
  zermio::Register reg_;

 public:
  /* I2C target address number 0 */
  zermio::BitField<0, 7, zermio::Permissions::ReadWrite> address0;
  /* I2C target mask number 0 */
  zermio::BitField<7, 7, zermio::Permissions::ReadWrite> mask0;
  /* I2C target address number 1 */
  zermio::BitField<14, 7, zermio::Permissions::ReadWrite> address1;
  /* I2C target mask number 1 */
  zermio::BitField<21, 7, zermio::Permissions::ReadWrite> mask1;
  constexpr TargetIdReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline TargetIdReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C target acquired data */
union AcqdataReg {
 private:
  zermio::Register reg_;

 public:
  /* Address for accepted transaction or acquired byte */
  zermio::BitField<0, 8, zermio::Permissions::Read> abyte;
  /* Host issued a START before transmitting ABYTE, a STOP or a RESTART after the preceeding ABYTE */
  zermio::BitField<8, 2, zermio::Permissions::Read> signal;
  constexpr AcqdataReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline AcqdataReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C target transmit data */
union TxdataReg {
 private:
  zermio::Register reg_;

 public:
  /* Value */
  zermio::BitField<0, 8, zermio::Permissions::Write> value;
  constexpr TxdataReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline TxdataReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* I2C host clock generation timeout value (in units of input clock frequency) */
union HostTimeoutCtrlReg {
 private:
  zermio::Register reg_;

 public:
  /* Value */
  zermio::BitField<0, 32, zermio::Permissions::ReadWrite> value;
  constexpr HostTimeoutCtrlReg(uintptr_t addr) : reg_{.addr = addr} {}

  inline void commit() { reg_.commit(); }

  inline HostTimeoutCtrlReg& fetch() {
    reg_.fetch();
    return *this;
  }
};

/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct I2c {
  CtrlReg ctrl;
  StatusReg status;
  RdataReg rdata;
  FdataReg fdata;
  FifoCtrlReg fifo_ctrl;
  FifoStatusReg fifo_status;
  OvrdReg ovrd;
  ValReg val;
  Timing0Reg timing0;
  Timing1Reg timing1;
  Timing2Reg timing2;
  Timing3Reg timing3;
  Timing4Reg timing4;
  TimeoutCtrlReg timeout_ctrl;
  TargetIdReg target_id;
  AcqdataReg acqdata;
  TxdataReg txdata;
  HostTimeoutCtrlReg host_timeout_ctrl;

  constexpr I2c(platform::I2c addr)
      : ctrl(addr + 0x10),
        status(addr + 0x14),
        rdata(addr + 0x18),
        fdata(addr + 0x1c),
        fifo_ctrl(addr + 0x20),
        fifo_status(addr + 0x24),
        ovrd(addr + 0x58),
        val(addr + 0x5c),
        timing0(addr + 0x60),
        timing1(addr + 0x64),
        timing2(addr + 0x68),
        timing3(addr + 0x6c),
        timing4(addr + 0x70),
        timeout_ctrl(addr + 0x74),
        target_id(addr + 0x78),
        acqdata(addr + 0x7c),
        txdata(addr + 0x80),
        host_timeout_ctrl(addr + 0x84) {}
};

}  // namespace i2c
}  // namespace mmio
