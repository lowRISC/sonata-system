/* Copyright lowRISC contributors.
* Licensed under the Apache License, Version 2.0; see LICENSE for details.
* SPDX-License-Identifier: Apache-2.0
*/

addrmap uart #(
    longint RxFifoDepth = 8,
    longint TxFifoDepth = 8,
    longint NumAlerts = 1
){
    xbar = '{
      parameter'{ type_: "bool", name: "pipeline", value:  "true" },
      parameter'{ type_: "bool", name: "req_fifo_pass", value:  "false" },
      parameter'{ type_: "bool", name: "rsp_fifo_pass", value:  "false" }
    };
    clk_input = '{ "clk_sys_i" };
    rst_input = '{ "rst_sys_ni" };

    // Interrupts
    signal { desc = "Raised when TX FIFO reaches watermark"; sigtype=SigType::Interrupt;} tx_watermark;
    signal { desc = "Raised when RX FIFO reaches watermark";sigtype=SigType::Interrupt;} rx_watermark;
    signal { desc = "Raised when TX FIFO becomes empty";sigtype=SigType::Interrupt;} tx_empty;
    signal { desc = "Raised when RX FIFO overflows";sigtype=SigType::Interrupt;} rx_overflow;
    signal { desc = "Raised on RX frame error";sigtype=SigType::Interrupt;} rx_frame_err;
    signal { desc = "Raised on RX break condition";sigtype=SigType::Interrupt;} rx_break_err;
    signal { desc = "Raised on RX timeout";sigtype=SigType::Interrupt;} rx_timeout;
    signal { desc = "Raised on RX parity error";sigtype=SigType::Interrupt;} rx_parity_err;

    // Ios pads.
    signal {sigtype=SigType::PadInput;} rx;
    signal {sigtype=SigType::PadOutput;} tx;

    reg {
        desc = "Interrupt State Register";
        field {
            sw = r;
            hw = rw;
            reset = true;
            desc = "raised if the transmit FIFO is past the high-water mark.";
        } TX_WATERMARK[0:0];
        field {
            sw = r;
            hw = rw;
            reset = false;
            desc = "raised if the receive FIFO is past the high-water mark.";
        } RX_WATERMARK[1:1];
        field {
            sw = rw;
            onwrite = woclr;
            hw = rw;
            reset = false;
            desc = "raised if the transmit FIFO has emptied and no transmit is ongoing.";
        } TX_DONE[2:2];
        field {
            sw = rw;
            onwrite = woclr;
            hw = rw;
            reset = false;
            desc = "raised if the receive FIFO has overflowed.";
        } RX_OVERFLOW[3:3];
        field {
            sw = rw;
            onwrite = woclr;
            hw = rw;
            reset = false;
            desc = "raised if a framing error has been detected on receive.";
        } RX_FRAME_ERR[4:4];
        field {
            sw = rw;
            onwrite = woclr;
            hw = rw;
            reset = false;
            desc = "raised if break condition has been detected on receive.";
        } RX_BREAK_ERR[5:5];
        field {
            sw = rw;
            onwrite = woclr;
            hw = rw;
            reset = false;
            desc = "raised if RX FIFO has characters remaining in the FIFO without beingretrieved for the programmed time period.";
        } RX_TIMEOUT[6:6];
        field {
            sw = rw;
            onwrite = woclr;
            hw = rw;
            reset = false;
            desc = "raised if the receiver has detected a parity error.";
        } RX_PARITY_ERR[7:7];
        field {
            sw = r;
            hw = rw;
            reset = true;
            desc = "raised if the transmit FIFO is empty.";
        } TX_EMPTY[8:8];
    } INTR_STATE @ 0x0;

    reg {
        desc = "Interrupt Enable Register";
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.tx_watermark is set.";
        } TX_WATERMARK[0:0];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.rx_watermark is set.";
        } RX_WATERMARK[1:1];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.tx_done is set.";
        } TX_DONE[2:2];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.rx_overflow is set.";
        } RX_OVERFLOW[3:3];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.rx_frame_err is set.";
        } RX_FRAME_ERR[4:4];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.rx_break_err is set.";
        } RX_BREAK_ERR[5:5];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.rx_timeout is set.";
        } RX_TIMEOUT[6:6];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.rx_parity_err is set.";
        } RX_PARITY_ERR[7:7];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable interrupt when !!INTR_STATE.tx_empty is set.";
        } TX_EMPTY[8:8];
    } INTR_ENABLE @ 0x4;

    external reg {
        desc = "Interrupt Test Register";
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.tx_watermark to 1.";
        } TX_WATERMARK[0:0];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.rx_watermark to 1.";
        } RX_WATERMARK[1:1];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.tx_done to 1.";
        } TX_DONE[2:2];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.rx_overflow to 1.";
        } RX_OVERFLOW[3:3];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.rx_frame_err to 1.";
        } RX_FRAME_ERR[4:4];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.rx_break_err to 1.";
        } RX_BREAK_ERR[5:5];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.rx_timeout to 1.";
        } RX_TIMEOUT[6:6];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.rx_parity_err to 1.";
        } RX_PARITY_ERR[7:7];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to force !!INTR_STATE.tx_empty to 1.";
        } TX_EMPTY[8:8];
    } INTR_TEST @ 0x8;

    external reg {
        desc = "Alert Test Register";
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "Write 1 to trigger one alert event of this kind.";
        } FATAL_FAULT[0:0];
    } ALERT_TEST @ 0xC;

    reg {
        desc = "UART control register";
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "TX enable";
        } TX[0:0];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "RX enable";
        } RX[1:1];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "RX noise filter enable.If the noise filter is enabled, RX line goes through the 3-taprepetition code. It ignores single IP clock period noise.";
        } NF[2:2];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "System loopback enable.If this bit is turned on, any outgoing bits to TX are received through RX.See Block Diagram. Note that the TX line goes 1 if System loopback is enabled.";
        } SLPBK[4:4];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Line loopback enable.If this bit is turned on, incoming bits are forwarded to TX for testing purpose.See Block Diagram. Note that the internal design sees RX value as 1 always if lineloopback is enabled.";
        } LLPBK[5:5];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "If true, parity is enabled in both RX and TX directions.";
        } PARITY_EN[6:6];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even.";
        } PARITY_ODD[7:7];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Trigger level for RX break detection. Sets the number of charactertimes the line must be low to detect a break.";
        } RXBLVL[9:8];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "BAUD clock rate control.";
        } NCO[31:16];
    } CTRL @ 0x10;

    external reg {
        hwre = true;
        desc = "UART live status register";
        field {
            sw = r;
            hw = rw;
            desc = "TX buffer is full";
        } TXFULL[0:0];
        field {
            sw = r;
            hw = rw;
            desc = "RX buffer is full";
        } RXFULL[1:1];
        field {
            sw = r;
            hw = rw;
            reset = true;
            desc = "TX FIFO is empty";
        } TXEMPTY[2:2];
        field {
            sw = r;
            hw = rw;
            reset = true;
            desc = "TX FIFO is empty and all bits have been transmitted";
        } TXIDLE[3:3];
        field {
            sw = r;
            hw = rw;
            reset = true;
            desc = "RX is idle";
        } RXIDLE[4:4];
        field {
            sw = r;
            hw = rw;
            reset = true;
            desc = "RX FIFO is empty";
        } RXEMPTY[5:5];
    } STATUS @ 0x14;

    external reg {
        hwre = true;
        desc = "UART read data";
        field {
            sw = r;
            hw = rw;
        } RDATA[7:0];
    } RDATA @ 0x18;

    reg {
        desc = "UART write data";
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
        } WDATA[7:0];
    } WDATA @ 0x1C;

    reg {
        desc = "UART FIFO control register";
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0";
        } RXRST[0:0];
        field {
            sw = w;
            hw = r;
            reset = 0x0;
            swmod = true;
            desc = "TX fifo reset. Write 1 to the register resets TX_FIFO. Read returns 0";
        } TXRST[1:1];
        field {
            sw = rw;
            hw = rw;
            reset = 0x0;
            swmod = true;
            desc = "Trigger level for RX interrupts. If the FIFO depth is greater than or equal tothe setting, it raises rx_watermark interrupt.";
        } RXILVL[4:2];
        field {
            sw = rw;
            hw = rw;
            reset = 0x0;
            swmod = true;
            desc = "Trigger level for TX interrupts. If the FIFO depth is less than the setting, itraises tx_watermark interrupt.";
        } TXILVL[7:5];
    } FIFO_CTRL @ 0x20;

    external reg {
        desc = "UART FIFO status register";
        field {
            sw = r;
            hw = w;
            desc = "Current fill level of TX fifo";
        } TXLVL[7:0];
        field {
            sw = r;
            hw = w;
            desc = "Current fill level of RX fifo";
        } RXLVL[23:16];
    } FIFO_STATUS @ 0x24;

    reg {
        desc = "TX pin override control. Gives direct SW control over TX pin state";
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable TX pin override control";
        } TXEN[0:0];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Write to set the value of the TX pin";
        } TXVAL[1:1];
    } OVRD @ 0x28;

    external reg {
        desc = "UART oversampled values";
        field {
            sw = r;
            hw = w;
            desc = "Last 16 oversampled values of RX. Most recent bit is bit 0, oldest 15.";
        } RX[15:0];
    } VAL @ 0x2C;

    reg {
        desc = "UART RX timeout control";
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "RX timeout value in UART bit times";
        } VAL[23:0];
        field {
            sw = rw;
            hw = r;
            reset = 0x0;
            desc = "Enable RX timeout feature";
        } EN[31:31];
    } TIMEOUT_CTRL @ 0x30;

};
