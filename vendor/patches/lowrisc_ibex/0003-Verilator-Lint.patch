diff --git a/rtl/cheri_ex.sv b/rtl/cheri_ex.sv
index 7b1b6b2..0181bc9 100644
--- a/rtl/cheri_ex.sv
+++ b/rtl/cheri_ex.sv
@@ -2,6 +2,8 @@
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
+/* verilator lint_off UNUSED */
+
 module cheri_ex import cheri_pkg::*; #(
   parameter bit          WritebackStage = 1'b0,
   parameter int unsigned HeapBase,
@@ -184,14 +186,14 @@ module cheri_ex import cheri_pkg::*; #(
   logic  [31:0]  addr_result;
 
   logic          intl_lsu_req;
-  logic          intl_lsu_we;
+  logic          unused_intl_lsu_we;
   logic [31:0]   intl_lsu_addr;
   logic [32:0]   intl_lsu_wdata;
   reg_cap_t      intl_lsu_wcap;
   logic          intl_lsu_is_cap;
 
   logic          clbc_done;
-  logic          clbc_err, clbc_err_q;
+  logic          clbc_err;
   logic  [31:0]  clbc_data_q;
   reg_cap_t      clbc_cap_q;
   logic          clbc_revoked;
@@ -317,7 +319,7 @@ module cheri_ex import cheri_pkg::*; #(
     unique case (1'b1)
       cheri_operator_i[CGET_PERM]:
         begin
-          result_data_o       = rf_fullcap_a.perms;
+          result_data_o       = {19'h0, rf_fullcap_a.perms};
           result_cap_o        = NULL_REG_CAP;   // zerout the cap msw
           cheri_rf_we_raw     = 1'b1;
           cheri_ex_valid_raw  = 1'b1;
@@ -338,7 +340,7 @@ module cheri_ex import cheri_pkg::*; #(
         end
       cheri_operator_i[CGET_TOP]:
         begin
-          result_data_o       = rf_fullcap_a.top33[32]? 32'hffff_ffff : rf_fullcap_a.top33;
+          result_data_o       = rf_fullcap_a.top33[32] ? 32'hffff_ffff : rf_fullcap_a.top33[31:0];
           result_cap_o        = NULL_REG_CAP;
           cheri_rf_we_raw     = 1'b1;
           cheri_ex_valid_raw  = 1'b1;
@@ -352,7 +354,7 @@ module cheri_ex import cheri_pkg::*; #(
         end
       cheri_operator_i[CGET_TAG]:
         begin
-          result_data_o       = rf_fullcap_a.valid;
+          result_data_o       = {31'h0, rf_fullcap_a.valid};
           result_cap_o        = NULL_REG_CAP;
           cheri_rf_we_raw     = 1'b1;
           cheri_ex_valid_raw  = 1'b1;
@@ -369,7 +371,7 @@ module cheri_ex import cheri_pkg::*; #(
           result_data_o        = rf_rdata_a;
 
           if (cheri_operator_i[CSEAL])
-            result_cap_o       = full2regcap(seal_cap(rf_fullcap_a, rf_rdata_b[3:0]));
+            result_cap_o       = full2regcap(seal_cap(rf_fullcap_a, rf_rdata_b[OTYPE_W-1:0]));
           else begin
             tfcap                = unseal_cap(rf_fullcap_a);
             tfcap.perms[PERM_GL] = rf_fullcap_a.perms[PERM_GL] & rf_fullcap_b.perms[PERM_GL];
@@ -385,7 +387,7 @@ module cheri_ex import cheri_pkg::*; #(
         begin
           result_data_o      = rf_rdata_a;
           tfcap              = rf_fullcap_a;
-          tfcap.perms        = tfcap.perms & rf_rdata_b;
+          tfcap.perms        = tfcap.perms & rf_rdata_b[PERMS_W-1:0];
           tfcap.cperms       = compress_perms(tfcap.perms, tfcap.cperms[5:4]);
           tfcap.valid        = tfcap.valid & ~is_cap_sealed(rf_fullcap_a);
           result_cap_o       = full2regcap(tfcap);
@@ -450,15 +452,15 @@ module cheri_ex import cheri_pkg::*; #(
         end
       cheri_operator_i[CIS_SUBSET]:      // rd <-- (cs1.tag == cs2.tag) && (cs2 is_subset_of cs1)
         begin
-          result_data_o       = (rf_fullcap_a.valid  == rf_fullcap_b.valid) &&
-                                 ~addr_bound_vio && (&(rf_fullcap_a.perms | ~rf_fullcap_b.perms));
+          result_data_o       = 32'((rf_fullcap_a.valid  == rf_fullcap_b.valid) &&
+                                 ~addr_bound_vio && (&(rf_fullcap_a.perms | ~rf_fullcap_b.perms)));
           result_cap_o        = NULL_REG_CAP;
           cheri_rf_we_raw     = 1'b1;
           cheri_ex_valid_raw  = 1'b1;
         end
       cheri_operator_i[CIS_EQUAL]:       // rd <-- (cs1 == cs2)
         begin
-          result_data_o       = is_equal(rf_fullcap_a, rf_fullcap_b, rf_rdata_a, rf_rdata_b);
+          result_data_o       = 32'(is_equal(rf_fullcap_a, rf_fullcap_b, rf_rdata_a, rf_rdata_b));
           result_cap_o        = NULL_REG_CAP;
           cheri_rf_we_raw     = 1'b1;
           cheri_ex_valid_raw  = 1'b1;
@@ -622,7 +624,7 @@ module cheri_ex import cheri_pkg::*; #(
   end
 
   assign cheri_lsu_we       = is_intl ? 1'b0 : is_store_cap;
-  assign cheri_lsu_addr     = (is_intl ? intl_lsu_addr : cs1_addr_plusimm) + {addr_incr_req_i, 2'b00};
+  assign cheri_lsu_addr     = (is_intl ? intl_lsu_addr : cs1_addr_plusimm) + {29'h0, addr_incr_req_i, 2'b00};
   assign cheri_lsu_is_cap   = is_intl ? intl_lsu_is_cap : is_cap;
   assign cheri_lsu_is_intl  = is_intl;
 
@@ -696,7 +698,7 @@ module cheri_ex import cheri_pkg::*; #(
     setaddr1_outcap = set_address(tfcap1, taddr1, 0, 0);
   end
 
-  bound_req_t bound_req1, bound_req2;
+  bound_req_t bound_req1;
 
   always_comb begin: set_bounds_comb
     logic [31:0] newlen;
@@ -716,7 +718,7 @@ module cheri_ex import cheri_pkg::*; #(
       tfcap3 = rf_fullcap_a;
       tmp_addr  = rf_rdata_a;
     end else if (cheri_operator_i[CSET_BOUNDS_IMM]) begin
-      newlen    = cheri_imm12_i;  // unsigned imm
+      newlen    = 32'(cheri_imm12_i);  // unsigned imm
       req_exact = 1'b0;
       tfcap3 = rf_fullcap_a;
       tmp_addr  = rf_rdata_a;
@@ -734,31 +736,10 @@ module cheri_ex import cheri_pkg::*; #(
 
     bound_req1 = prep_bound_req (tmp_addr, newlen);
 
-    setbounds_outcap = set_bounds(tfcap3, tmp_addr, bound_req2, req_exact);
+    setbounds_outcap = set_bounds(tfcap3, tmp_addr, bound_req1, req_exact);
   end
 
-  if (CheriSBND2) begin
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        bound_req2      <= '{0, 0, 0};
-        set_bounds_done <= 1'b0;
-      end else begin
-        bound_req2      <= bound_req1;
-        // set_bounds_done is asserted in the 2nd cycle of execution when SBD2 == 1
-        // note in ibex it actaully is ok to hold set_bounds_done high for both cycles
-        // since the multicycle control logic won't look at ex_valid till the 2nd cycle
-        // however this is the cleaner solution.
-        set_bounds_done <= (cheri_operator_i[CSET_BOUNDS] | cheri_operator_i[CSET_BOUNDS_IMM] |
-                            cheri_operator_i[CSET_BOUNDS_EX] | cheri_operator_i[CRRL] | 
-                            cheri_operator_i[CRAM]) & cheri_exec_id_i & ~set_bounds_done ;
-      end
-    end
-  end else begin
-    assign bound_req2      = bound_req1;
-    assign set_bounds_done = 1'b1;
-  end
-
-
+  assign set_bounds_done = 1'b1;
 
   // address bound and permission checks for
   //    - cheri no-LSU instructions
@@ -777,9 +758,9 @@ module cheri_ex import cheri_pkg::*; #(
   always_comb begin : check_rv32
     logic [31:0] top_offset;
     logic [32:0] top_bound;
-    logic [31:0] base_bound;
+    logic [31:0] base_bound, base_chkaddr;
     logic        top_vio, base_vio;
-    logic [32:0] top_chkaddr, base_chkaddr;
+    logic [32:0] top_chkaddr;
     logic        top_size_ok;
 
     // generate the address used to check top bound violation
@@ -797,7 +778,7 @@ module cheri_ex import cheri_pkg::*; #(
     end
 
     //top_chkaddr = base_chkaddr + top_offset;
-    top_chkaddr = base_chkaddr;
+    top_chkaddr = {1'b0, base_chkaddr};
 
     // top_bound  = rf_fullcap_a.top33;
     top_bound  = rf_fullcap_a.top33 - top_offset;
@@ -836,8 +817,8 @@ module cheri_ex import cheri_pkg::*; #(
   always_comb begin : check_cheri
     logic [31:0] top_offset;
     logic [32:0] top_bound;
-    logic [31:0] base_bound;
-    logic [32:0] top_chkaddr, base_chkaddr;
+    logic [31:0] base_bound, base_chkaddr;
+    logic [32:0] top_chkaddr;
     logic        top_vio, base_vio, top_equal;
     logic        cs2_bad_type;
 
@@ -852,9 +833,9 @@ module cheri_ex import cheri_pkg::*; #(
     if (cheri_operator_i[CIS_SUBSET])
       top_chkaddr = rf_fullcap_b.top33;
     else if (is_cap)  // CLC/CSC
-      top_chkaddr = {base_chkaddr[31:3], 3'b000};
+      top_chkaddr = {1'b0, base_chkaddr[31:3], 3'b000};
     else 
-      top_chkaddr = base_chkaddr;
+      top_chkaddr = {1'b0, base_chkaddr};
 
     if (cheri_operator_i[CSEAL] | cheri_operator_i[CUNSEAL]) begin
       top_bound  = rf_fullcap_b.top33;
@@ -912,7 +893,7 @@ module cheri_ex import cheri_pkg::*; #(
     end else if (cheri_operator_i[CUNSEAL]) begin
       perm_vio_vec[PVIO_TAG]   = ~rf_fullcap_a.valid || ~rf_fullcap_b.valid; 
       perm_vio_vec[PVIO_SEAL]  = (~is_cap_sealed(rf_fullcap_a)) || is_cap_sealed(rf_fullcap_b) ||
-                                   (rf_rdata_b != decode_otype(rf_fullcap_a.otype, rf_fullcap_a.perms[PERM_EX])) ||
+                                   (rf_rdata_b != {28'h0, decode_otype(rf_fullcap_a.otype, rf_fullcap_a.perms[PERM_EX])}) ||
                                    (~rf_fullcap_b.perms[PERM_US]);
     end else if (cheri_operator_i[CJALR]) begin
       perm_vio_vec[PVIO_TAG]   = (~rf_fullcap_a.valid);
@@ -1014,9 +995,10 @@ module cheri_ex import cheri_pkg::*; #(
     logic  [4:0] ts_map_bitpos;    // bit index in a 32-bit word
     logic        clbc_map_ok;
     logic [31:0] clbc_map_q;
+    logic        clbc_err_q;
 
     assign clbc_revoked    = clbc_map_ok && clbc_map_q[ts_map_bitpos] & cheri_tsafe_en_i;
-    assign intl_lsu_we    = 1'b0;
+    assign unused_intl_lsu_we    = 1'b0;
     assign intl_lsu_wdata = 33'h0;
     assign intl_lsu_wcap  = NULL_REG_CAP;
 
@@ -1099,9 +1081,17 @@ module cheri_ex import cheri_pkg::*; #(
     assign intl_lsu_req    = 1'b0;
     assign intl_lsu_is_cap = 1'b0;
     assign intl_lsu_addr   = 32'h0;
-    assign intl_lsu_we     = 1'b0;
+    assign unused_intl_lsu_we = 1'b0;
     assign intl_lsu_wdata  = 33'h0;
     assign intl_lsu_wcap   = NULL_REG_CAP;
+    assign clbc_done = 1'b0;
+    assign clbc_err = 1'b0;
+    assign clbc_revoked = 1'b1;
+
+    always_ff @(posedge clk_i) begin
+      clbc_data_q <= 32'h0;
+      clbc_cap_q <= NULL_REG_CAP;
+    end
   end
 
   //
@@ -1222,30 +1212,32 @@ end
   // debug signal for FPGA only
   //
   logic [15:0] dbg_status;
-  logic [68:0] dbg_cs1_vec, dbg_cs2_vec, dbg_cd_vec;
+  logic [67:0] dbg_cs1_vec, dbg_cs2_vec, dbg_cd_vec;
 
   assign dbg_status = {4'h0,
                        instr_is_rv32lsu_i, rv32_lsu_req_i, rv32_lsu_we_i,  rv32_lsu_err,
                        cheri_exec_id_i, cheri_lsu_err, rf_fullcap_a.valid, result_cap_o.valid,
                        addr_bound_vio, perm_vio, addr_bound_vio_rv32, perm_vio_rv32};
 
-  assign dbg_cs1_vec = {rf_fullcap_a.top_cor, rf_fullcap_a.base_cor, // 68:65
-                        rf_fullcap_a.exp,                            // 64:60
-                        rf_fullcap_a.top, rf_fullcap_a.base,         // 59:42
-                        rf_fullcap_a.otype, rf_fullcap_a.cperms,     // 41:32
+  assign dbg_cs1_vec = {rf_fullcap_a.top_cor, rf_fullcap_a.base_cor, // 67:64
+                        rf_fullcap_a.exp,                            // 63:59
+                        rf_fullcap_a.top, rf_fullcap_a.base,         // 58:41
+                        rf_fullcap_a.otype, rf_fullcap_a.cperms,     // 40:32
                         rf_rdata_a};                                 // 31:0
 
-  assign dbg_cs2_vec = {rf_fullcap_b.top_cor, rf_fullcap_b.base_cor, // 68:65
-                        rf_fullcap_b.exp,                            // 64:60
-                        rf_fullcap_b.top, rf_fullcap_b.base,         // 59:42
-                        rf_fullcap_b.otype, rf_fullcap_b.cperms,     // 41:32
+  assign dbg_cs2_vec = {rf_fullcap_b.top_cor, rf_fullcap_b.base_cor, // 67:64
+                        rf_fullcap_b.exp,                            // 63:59
+                        rf_fullcap_b.top, rf_fullcap_b.base,         // 58:41
+                        rf_fullcap_b.otype, rf_fullcap_b.cperms,     // 40:32
                         rf_rdata_b};                                 // 31:0
 
-  assign dbg_cd_vec = {result_cap_o.top_cor, result_cap_o.base_cor,  // 68:65
-                        result_cap_o.exp,                            // 64:60
-                        result_cap_o.top, result_cap_o.base,         // 59:42
-                        result_cap_o.otype, result_cap_o.cperms,     // 41:32
+  assign dbg_cd_vec = {result_cap_o.top_cor, result_cap_o.base_cor,  // 67:64
+                        result_cap_o.exp,                            // 63:59
+                        result_cap_o.top, result_cap_o.base,         // 58:41
+                        result_cap_o.otype, result_cap_o.cperms,     // 40:32
                         result_data_o};                              // 31:0
 
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/cheri_pkg.sv b/rtl/cheri_pkg.sv
index ce014f4..43686dd 100644
--- a/rtl/cheri_pkg.sv
+++ b/rtl/cheri_pkg.sv
@@ -2,6 +2,9 @@
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
+
+/* verilator lint_off UNUSED */
+
 package cheri_pkg;
 
   // bit field widths
@@ -153,7 +156,7 @@ package cheri_pkg;
   `define TEST_IMSK(P, M) (&((P) | ~(M)))
 
   // compress perms field to memory representation
-  function automatic logic [CPERMS_W-1:0] compress_perms (logic [PERMS_W-1:0] perms, logic [1:0] qqq);   // qqq is a place holder, just to compatible with the old encoding for now.
+  function automatic logic [CPERMS_W-1:0] compress_perms (logic [PERMS_W-1:0] perms, logic [1:0] unused_qqq);   // unused_qqq is a place holder, just to compatible with the old encoding for now.
     logic [CPERMS_W-1:0] cperms;
 
     // test all types encoding and determine encoding (Robert's priority order)
@@ -321,7 +324,7 @@ package cheri_pkg;
     if ((tmp24 != 0) || (chktop & ~top_lt) || (chkbase & tmp33[32]))
       out_cap.valid = 1'b0;
 
-    ptrmi9           = newptr >> in_cap.exp;
+    ptrmi9           = BOT_W'(newptr >> in_cap.exp);
     tmp4             = update_temp_fields(out_cap.top, out_cap.base, ptrmi9);
     out_cap.top_cor  = tmp4[3:2];
     out_cap.base_cor = tmp4[1:0];
@@ -330,7 +333,7 @@ package cheri_pkg;
   endfunction
 
 
-  // utillity function
+  // utility function
   // return the size (bit length) of input number without leading zeros
   function automatic logic [5:0] get_size(logic [31:0] din);
     logic  [5:0] count;
@@ -344,13 +347,13 @@ package cheri_pkg;
     else begin
       count[5] = 1'b0;
       count[4] = a32[15];
-      b32 = count[4] ? a32[31:16] : a32[15:0];
+      b32[15:0] = count[4] ? a32[31:16] : a32[15:0];
       count[3] = b32[7];
-      b32 = count[3] ?  b32[15:8]: b32[7:0];
+      b32[ 7:0] = count[3] ? b32[15:8] : b32[7:0];
       count[2] = b32[3];
-      b32 = count[2] ?  b32[7:4] : b32[3:0];
+      b32[ 3:0] = count[2] ?  b32[7:4] : b32[3:0];
       count[1] = b32[1];
-      b32 = count[1] ? b32[3:2] : b32[1:0];
+      b32[ 1:0] = count[1] ?  b32[3:2] : b32[1:0];
       count[0] = b32[0];
     end
 
@@ -362,12 +365,14 @@ package cheri_pkg;
   // break up into 2 parts to enable 2-cycle option
   function automatic bound_req_t prep_bound_req (logic [31:0] addr, logic [31:0] length);
     bound_req_t result;
+    logic [5:0] size_result;
+
     result.top33req = {1'b0, addr} + {1'b0, length};    // "requested" 33-bit top
 
-    result.exp1     = get_size({23'h0, length[31:9]});
-    result.exp1     = (result.exp1 >= RESETCEXP) ? RESETEXP : result.exp1;
-    result.exp2     = result.exp1+1;
-    result.exp2     = (result.exp2 >= RESETCEXP) ? RESETEXP : result.exp2;
+    size_result     = get_size({9'h0, length[31:9]});
+    result.exp1     = (size_result >= 6'(RESETCEXP)) ? EXP_W'(RESETEXP) : EXP_W'(size_result);
+    size_result     += 1;
+    result.exp2     = (size_result >= 6'(RESETCEXP)) ? EXP_W'(RESETEXP) : EXP_W'(size_result);
 
     return result;
   endfunction
@@ -378,7 +383,7 @@ package cheri_pkg;
 
     logic [EXP_W-1:0] exp1, exp2, expr;
     logic [32:0]      top33req;
-    logic [9:0]       base1, base2, top1, top2, len1, len2;
+    logic [BOT_W:0]   base1, base2, top1, top2, len1, len2;
     logic [32:0]      mask1, mask2;
     logic             ovrflw, topoff1, topoff2, topoff;
     logic             baseoff1, baseoff2, baseoff;
@@ -392,10 +397,10 @@ package cheri_pkg;
 
     // 1st path
     mask1    = {33{1'b1}} << exp1;
-    base1    = addr >> exp1;
+    base1    = (BOT_W+1)'(addr >> exp1);
     topoff1  = |(top33req & ~mask1);
-    baseoff1 = |(addr & ~mask1);
-    top1     = (top33req >> exp1) + topoff1;
+    baseoff1 = |({1'b0, addr} & ~mask1);
+    top1     = (BOT_W+1)'(top33req >> exp1) + (BOT_W+1)'(topoff1);
     len1     = top1 - base1;
     tophi1   = (top1[8:0] >= base1[8:0]);
 
@@ -404,28 +409,28 @@ package cheri_pkg;
 
     // 2nd path in parallel
     mask2    = {33{1'b1}} << exp2;
-    base2    = addr >> exp2;
+    base2    = (BOT_W+1)'(addr >> exp2);
     topoff2  = |(top33req & ~mask2);
-    baseoff2 = |(addr & ~mask2);
-    top2     = (top33req >> exp2) + topoff2;
+    baseoff2 = |({1'b0, addr} & ~mask2);
+    top2     = (BOT_W+1)'(top33req >> exp2) + (BOT_W+1)'(topoff2);
     len2     = top2 - base2;
     tophi2   = (top2[8:0] >= base2[8:0]);
 
     // select results
     if (~ovrflw) begin
       out_cap.exp   = exp1;
-      out_cap.top   = top1;
-      out_cap.base  = base1;
-      out_cap.maska = mask1;
+      out_cap.top   = top1[TOP_W-1:0];
+      out_cap.base  = base1[BOT_W-1:0];
+      out_cap.maska = mask1[31:0];
       out_cap.rlen  = {22'h0, len1} << exp1;
       topoff        = topoff1;
       baseoff       = baseoff1;
       tophi         = tophi1;
     end else begin
       out_cap.exp   = exp2;
-      out_cap.top   = top2;
-      out_cap.base  = base2;
-      out_cap.maska = mask2;
+      out_cap.top   = top2[TOP_W-1:0];
+      out_cap.base  = base2[BOT_W-1:0];
+      out_cap.maska = mask2[31:0];
       out_cap.rlen  = {22'h0, len2} << exp2;
       topoff        = topoff2;
       baseoff       = baseoff2;
@@ -511,7 +516,7 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     full_cap.rsvd     = reg_cap.rsvd;
 
     full_cap.top33  = get_bound33(reg_cap.top, reg_cap.top_cor, reg_cap.exp, addr);
-    full_cap.base32 = get_bound33(reg_cap.base, reg_cap.base_cor, reg_cap.exp, addr);
+    full_cap.base32 = 32'(get_bound33(reg_cap.base, reg_cap.base_cor, reg_cap.exp, addr));
     // full_cap  = update_bounds(full_cap, addr);   // for some reason this increases area 
 
     full_cap.maska    = 0;
@@ -553,10 +558,10 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     pcc_fullcap.base32   = in_pcap.base32;
     pcc_fullcap.otype    = in_pcap.otype;
     pcc_fullcap.perms    = in_pcap.perms;
-    pcc_fullcap.top_cor  = 1'b0;          // will be updated by set_address()
-    pcc_fullcap.base_cor = 1'b0;
-    pcc_fullcap.top      = in_pcap.top33  >> (in_pcap.exp);
-    pcc_fullcap.base     = in_pcap.base32 >> (in_pcap.exp);
+    pcc_fullcap.top_cor  = 2'b0;          // will be updated by set_address()
+    pcc_fullcap.base_cor = 2'b0;
+    pcc_fullcap.top      = TOP_W'(in_pcap.top33  >> (in_pcap.exp));
+    pcc_fullcap.base     = BOT_W'(in_pcap.base32 >> (in_pcap.exp));
     pcc_fullcap.cperms   = in_pcap.cperms;
     pcc_fullcap.maska    = 0;             // not used in pcc_cap
     pcc_fullcap.rsvd     = in_pcap.rsvd;
@@ -609,7 +614,7 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
 
   function automatic reg_cap_t mem2regcap_fmt0 (logic [32:0] msw, logic [32:0] addr33, logic [3:0] clrperm);
     reg_cap_t regcap;
-    logic [31:0] tmp32;
+    logic [EXP_W-1:0] tmp5;
     logic [3:0]  tmp4;
     logic [CPERMS_W-1:0] cperms_mem;
     logic [BOT_W-1:0]    addrmi9;
@@ -619,9 +624,9 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     valid_in      = msw[32] & addr33[32];
     regcap.valid  = valid_in & ~clrperm[3];   
 
-    tmp32    = msw[CEXP_LO+:CEXP_W];
-    if (tmp32 == RESETCEXP) tmp32 = RESETEXP;
-    regcap.exp    = tmp32;
+    tmp5 = {1'b0, msw[CEXP_LO+:CEXP_W]};
+    if (tmp5 == EXP_W'(RESETCEXP)) tmp5 = RESETEXP;
+    regcap.exp = tmp5;
 
     regcap.top    = msw[TOP_LO+:TOP_W];
     regcap.base   = msw[BASE_LO+:BOT_W];
@@ -630,7 +635,7 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     sealed = (regcap.otype != OTYPE_UNSEALED);
     cperms_mem      = msw[CPERMS_LO+:CPERMS_W];
     regcap.cperms   = mask_clcperms(cperms_mem, clrperm, valid_in, sealed);
-    addrmi9         = {1'b0, addr33[31:0]} >> regcap.exp;   // ignore the tag valid bit 
+    addrmi9         = BOT_W'({1'b0, addr33[31:0]} >> regcap.exp); // ignore the tag valid bit
     tmp4            = update_temp_fields(regcap.top, regcap.base, addrmi9);
     regcap.top_cor  = tmp4[3:2];
     regcap.base_cor = tmp4[1:0];
@@ -665,7 +670,7 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
 
   function automatic reg_cap_t mem2regcap_fmt1 (logic [32:0] msw, logic [32:0] lsw, logic [3:0] clrperm);
     reg_cap_t regcap;
-    logic [31:0] tmp32;
+    logic [3:0]  tmp4;
     logic        sealed;
     logic [8:0]  addrmi9;
     logic [CPERMS_W-1:0] cperms_mem;
@@ -677,7 +682,7 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     regcap.exp    = (lsw[30:27] == RESETCEXP) ?  RESETEXP : {1'b0, lsw[30:27]};
     regcap.base   = lsw[26:18];
     regcap.top    = lsw[17:9];
-    addrmi9       = (lsw[30:27] == RESETCEXP) ? lsw[8:1] : lsw[8:0];
+    addrmi9       = (lsw[30:27] == RESETCEXP) ? {1'b0, lsw[8:1]} : lsw[8:0];
 
     regcap.otype  = msw[25:23];
     sealed        = (regcap.otype != OTYPE_UNSEALED);
@@ -687,9 +692,9 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     regcap.cperms = mask_clcperms(cperms_mem, clrperm, valid_in, sealed);
     regcap.rsvd   = lsw[31];
 
-    tmp32 = update_temp_fields(regcap.top, regcap.base, addrmi9);
-    regcap.top_cor  = tmp32[3:2];
-    regcap.base_cor = tmp32[1:0];
+    tmp4 = update_temp_fields(regcap.top, regcap.base, addrmi9);
+    regcap.top_cor  = tmp4[3:2];
+    regcap.base_cor = tmp4[1:0];
 
     return regcap;
 
@@ -701,15 +706,15 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
     logic [31:0] mask1, mask2;
 
     if (reg_cap.exp == RESETEXP) begin
-      addrhi   = 33'h0;
+      addrhi   = 32'h0;
       addrmi   = {lsw[8:0], 23'h0};
-      addrlo   = msw[22:0];
+      addrlo   = {9'h0, msw[22:0]};
     end else begin
-      addrmi   = lsw[8:0] << reg_cap.exp;
-      mask1    = {33{1'b1}} << reg_cap.exp;
+      addrmi   = {23'h0, lsw[8:0]} << reg_cap.exp;
+      mask1    = {32{1'b1}} << reg_cap.exp;
       mask2    = mask1 << 9;
-      addrhi   = (msw[22:0] << 9) & mask2;
-      addrlo   = msw[22:0] & (~mask1);
+      addrhi   = ({9'h0, msw[22:0]} << 9) & mask2;
+      addrlo   = {9'h0, msw[22:0]} & (~mask1);
     end
 
     addr33 = {lsw[32], addrhi | addrmi |addrlo};
@@ -735,12 +740,12 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
       lsw[30:27] = RESETCEXP;
       lsw[8:0]   = addr[31:23];
     end else begin
-      mask1    = {33{1'b1}} << reg_cap.exp;
+      mask1    = {32{1'b1}} << reg_cap.exp;
       mask2    = mask1 << 9;
 
-      msw[22:0]  = (addr & ~mask1) | ((addr & mask2) >> 9);
+      msw[22:0]  = 23'((addr & ~mask1) | ((addr & mask2) >> 9));
       lsw[30:27] = reg_cap.exp[CEXP_W-1:0];
-      lsw[8:0]   = addr >> reg_cap.exp;
+      lsw[8:0]   = 9'(addr >> reg_cap.exp);
     end
 
     return {msw, lsw};
@@ -892,3 +897,5 @@ $display("--- set_bounds:  b1 = %x, t1 = %x, b2 = %x, t2 = %x", base1, top1, bas
   endfunction
  
 endpackage
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/cheri_regfile.sv b/rtl/cheri_regfile.sv
index 5b23a22..2192536 100644
--- a/rtl/cheri_regfile.sv
+++ b/rtl/cheri_regfile.sv
@@ -3,6 +3,8 @@
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
+/* verilator lint_off UNUSED */
+
 module cheri_regfile import cheri_pkg::*; #(
   parameter int unsigned NREGS      = 32,
   parameter int unsigned NCAPS      = 32,
@@ -80,7 +82,6 @@ module cheri_regfile import cheri_pkg::*; #(
 
   // No flops for R0 as it's hard-wired to 0
   for (genvar i = 1; i < NREGS; i++) begin : g_rf_flops
-    logic cap_valid;
     
     
     always_ff @(posedge clk_i or negedge rst_ni) begin
@@ -121,8 +122,8 @@ module cheri_regfile import cheri_pkg::*; #(
     assign rf_reg_par[i] = rf_reg_par_q[i];     
   end
 
-  assign rdata_a_o = {rf_reg_par[raddr_a_i], rf_reg[raddr_a_i]};
-  assign rdata_b_o = {rf_reg_par[raddr_b_i], rf_reg[raddr_b_i]};
+  assign rdata_a_o = DataWidth'({rf_reg_par[raddr_a_i], rf_reg[raddr_a_i]});
+  assign rdata_b_o = DataWidth'({rf_reg_par[raddr_b_i], rf_reg[raddr_b_i]});
 
   // capability meta data (MSW)
   for (genvar i = 1; i < NCAPS; i++) begin : g_cap_flops
@@ -143,8 +144,8 @@ module cheri_regfile import cheri_pkg::*; #(
     assign rf_cap[i] = rf_cap_q[i];
   end
 
-  assign rcap_a = (raddr_a_i < NCAPS) ? rf_cap[raddr_a_i] : NULL_REG_CAP;
-  assign rcap_b = (raddr_b_i < NCAPS) ? rf_cap[raddr_b_i] : NULL_REG_CAP;
+  assign rcap_a = (int'(raddr_a_i) < NCAPS) ? rf_cap[raddr_a_i] : NULL_REG_CAP;
+  assign rcap_b = (int'(raddr_b_i) < NCAPS) ? rf_cap[raddr_b_i] : NULL_REG_CAP;
 
   if (CheriPPLBC) begin : g_regrdy
 
@@ -367,3 +368,5 @@ module cheri_regfile import cheri_pkg::*; #(
 
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/cheri_tbre_wrapper.sv b/rtl/cheri_tbre_wrapper.sv
index cef116a..18f1e76 100644
--- a/rtl/cheri_tbre_wrapper.sv
+++ b/rtl/cheri_tbre_wrapper.sv
@@ -2,6 +2,7 @@
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
+/* verilator lint_off UNUSED */
 
 module cheri_tbre_wrapper import cheri_pkg::*; #(
   parameter bit          CHERIoTEn   = 1'b1,
@@ -82,7 +83,7 @@ module cheri_tbre_wrapper import cheri_pkg::*; #(
 
   logic          tbre_stat, tbre_err, stkz_err;
 
-  assign mmreg_coreout_o = {{(MMRegDoutW-8){1'b0}}, 2'b00, 2'b00, stkz_err, stkz_active_o,
+  assign mmreg_coreout_o = {{(MMRegDoutW-10){1'b0}}, 2'b00, 2'b00, stkz_err, stkz_active_o,
                                                     2'b00,  tbre_err, tbre_stat};
 
   if (CHERIoTEn & CheriTBRE) begin : g_tbre
@@ -190,7 +191,7 @@ module cheri_tbre_wrapper import cheri_pkg::*; #(
   for (genvar i = 0; i < nMSTR; i++) begin
     logic [7:0] pri_mask;
     assign pri_mask = 8'hff >> (8-i);      // max 8 masters, should be enough 
-    assign mstr_arbit[i] = mstr_req[i] & ~(|(mstr_req & pri_mask));
+    assign mstr_arbit[i] = mstr_req[i] & ~(|(mstr_req & pri_mask[nMSTR-1:0]));
   end
 
   // Handling delayed-gnt case. 
@@ -246,3 +247,5 @@ module cheri_tbre_wrapper import cheri_pkg::*; #(
 
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/cheri_trvk_stage.sv b/rtl/cheri_trvk_stage.sv
index 5ec5b8b..f29648c 100644
--- a/rtl/cheri_trvk_stage.sv
+++ b/rtl/cheri_trvk_stage.sv
@@ -2,6 +2,8 @@
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
+/* verilator lint_off UNUSED */
+
 module cheri_trvk_stage #(
   parameter int unsigned HeapBase,
   parameter int unsigned TSMapSize
@@ -50,18 +52,20 @@ module cheri_trvk_stage #(
 
   logic [31:0] base32;
   logic [31:0] tsmap_ptr;
-  logic  [4:0] bitpos, bitpos_q;    // bit index in a 32-bit word
+  logic  [4:0] bitpos_q; // bit index in a 32-bit word
   logic        range_ok;
   logic  [2:1] range_ok_q;
 
 
-  assign base32    = get_bound33(in_cap_q.base, in_cap_q.base_cor, in_cap_q.exp, in_data_q);
+  assign base32    = 32'(get_bound33(in_cap_q.base, in_cap_q.base_cor, in_cap_q.exp, in_data_q));
   assign tsmap_ptr = (base32 - HeapBase) >> 3;
 
+  /* verilator lint_off WIDTH */
   assign tsmap_addr_o  = tsmap_ptr[15:5];
+  /* verilator lint_on WIDTH */
 
   // not a sealling cap and pointing to valid TSMAP range
-  assign range_ok      = (tsmap_ptr[31:5] <= TSMapSize) && 
+  assign range_ok      = (int'(tsmap_ptr[31:5]) <= TSMapSize) &&
                          ~((in_cap_q.cperms[4:3]==2'b00) && (|in_cap_q.cperms[2:0]));
   assign tsmap_cs_o    = (cpu_op_valid_q[0] | tbre_op_valid_q[0]) & cap_good_q[0];
 
@@ -75,7 +79,7 @@ module cheri_trvk_stage #(
   always_ff @(posedge clk_i or negedge rst_ni) begin
     if (!rst_ni) begin
       cpu_op_active <= 1'b0;
-      trsv_addr  <= 4'h0;
+      trsv_addr  <= 5'h0;
     end else begin
       if (rf_trsv_en_i) cpu_op_active <= 1'b1;
       else if (lsu_resp_valid_i) cpu_op_active <= 1'b0;
@@ -91,7 +95,6 @@ module cheri_trvk_stage #(
                           (lsu_tbre_resp_valid_i & ~lsu_tbre_resp_err_i &  rf_wcap_lsu_i.valid);
 
   always_ff @(posedge clk_i or negedge rst_ni) begin
-    int i;
     if (!rst_ni) begin
       cpu_op_valid_q  <= 0;
       tbre_op_valid_q <= 0;
@@ -130,3 +133,5 @@ module cheri_trvk_stage #(
   end
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/ibex_controller.sv b/rtl/ibex_controller.sv
index e290391..adf2e11 100644
--- a/rtl/ibex_controller.sv
+++ b/rtl/ibex_controller.sv
@@ -14,6 +14,8 @@
 `include "prim_assert.sv"
 `include "dv_fcov_macros.svh"
 
+/* verilator lint_off UNUSED */
+
 module ibex_controller #(
   parameter bit CHERIoTEn       = 1'b1,
   parameter bit WritebackStage  = 0,
@@ -780,7 +782,7 @@ module ibex_controller #(
                   csr_mtval_o = lsu_addr_last_i;
                 end else begin
                   exc_cause_o = EXC_CAUSE_CHERI_FAULT; 
-                  csr_mtval_o = cheri_wb_err_info_i[10:0];
+                  csr_mtval_o = {21'h0, cheri_wb_err_info_i[10:0]};
                 end
               end else begin
                 exc_cause_o = EXC_CAUSE_STORE_ACCESS_FAULT;
@@ -794,7 +796,7 @@ module ibex_controller #(
                   csr_mtval_o = lsu_addr_last_i;
                 end else begin
                   exc_cause_o = EXC_CAUSE_CHERI_FAULT;
-                  csr_mtval_o = cheri_wb_err_info_i[10:0];
+                  csr_mtval_o = {21'h0, cheri_wb_err_info_i[10:0]};
                 end
               end else begin
                 exc_cause_o = EXC_CAUSE_LOAD_ACCESS_FAULT;
@@ -804,13 +806,13 @@ module ibex_controller #(
             cheri_ex_err_prio: begin
               if (cheri_pmode_i) begin
                 exc_cause_o = EXC_CAUSE_CHERI_FAULT;
-                csr_mtval_o = cheri_ex_err_info_i[10:0];        
+                csr_mtval_o = {21'h0, cheri_ex_err_info_i[10:0]};
               end
             end
             cheri_wb_err_prio: begin
               if (cheri_pmode_i) begin
                 exc_cause_o = EXC_CAUSE_CHERI_FAULT;
-                csr_mtval_o = cheri_wb_err_info_i[10:0];
+                csr_mtval_o = {21'h0, cheri_wb_err_info_i[10:0]};
               end
             end
 
@@ -1023,3 +1025,5 @@ module ibex_controller #(
   `endif
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/ibex_core.sv b/rtl/ibex_core.sv
index 8835c14..87fdf66 100644
--- a/rtl/ibex_core.sv
+++ b/rtl/ibex_core.sv
@@ -198,7 +198,6 @@ module ibex_core import ibex_pkg::*; import cheri_pkg::*; #(
   // IF/ID signals
   logic        dummy_instr_id;
   logic        instr_valid_id;
-  logic        instr_executing_id;
   logic        instr_new_id;
   logic [31:0] instr_rdata_id;                 // Instruction sampled inside IF stage
   logic [31:0] instr_rdata_alu_id;             // Instruction sampled inside IF stage (replicated to
@@ -259,8 +258,6 @@ module ibex_core import ibex_pkg::*; import cheri_pkg::*; #(
   logic        if_busy;
   logic        lsu_busy;
 
-  logic        lsu_busy_tbre;
-
   // Register File
   logic [4:0]  rf_raddr_a;
   logic [31:0] rf_rdata_a;
@@ -432,7 +429,12 @@ module ibex_core import ibex_pkg::*; import cheri_pkg::*; #(
   logic [11:0]   cheri_ex_err_info;
   logic          cheri_wb_err;
   logic [11:0]   cheri_wb_err_info;
+
+  /* verilator lint_off UNOPTFLAT */
+  /* verilator lint_off IMPERFECTSCH */
   logic [OPDW-1:0] cheri_operator;
+  /* verilator lint_on UNOPTFLAT */
+  /* verilator lint_on IMPERFECTSCH */
 
   logic          rv32_lsu_req;
   logic          rv32_lsu_we;
@@ -441,7 +443,6 @@ module ibex_core import ibex_pkg::*; import cheri_pkg::*; #(
   logic          rv32_lsu_sign_ext;
   logic          rv32_lsu_addr_incr_req;
   logic [31:0]   rv32_lsu_addr_last;
-  logic          rv32_lsu_resp_valid;
 
   logic          cheri_csr_access;
   logic [4:0]    cheri_csr_addr;
@@ -1209,7 +1210,7 @@ module ibex_core import ibex_pkg::*; import cheri_pkg::*; #(
 
     .busy_o(lsu_busy),
 
-    .busy_tbre_o(lsu_busy_tbre),
+    .busy_tbre_o(),
 
     .perf_load_o (perf_load),
     .perf_store_o(perf_store)
diff --git a/rtl/ibex_cs_registers.sv b/rtl/ibex_cs_registers.sv
index 2597a94..ef4bfc0 100644
--- a/rtl/ibex_cs_registers.sv
+++ b/rtl/ibex_cs_registers.sv
@@ -16,6 +16,8 @@
 
 `include "prim_assert.sv"
 
+/* verilator lint_off UNUSED */
+
 module ibex_cs_registers import cheri_pkg::*;  #(
   parameter bit               DbgTriggerEn      = 0,
   parameter int unsigned      DbgHwBreakNum     = 1,
@@ -173,7 +175,7 @@ module ibex_cs_registers import cheri_pkg::*;  #(
     | (0                 << 13)  // N - User level interrupts supported
     | (0                 << 18)  // S - Supervisor mode implemented
     | (1                 << 20)  // U - User mode implemented
-    | (CHERIoTEn         << 23)  // X - Non-standard extensions present
+    | (32'(CHERIoTEn)    << 23)  // X - Non-standard extensions present
     | (32'(CSR_MISA_MXL) << 30); // M-XLEN
 
   typedef struct packed {
@@ -1994,3 +1996,5 @@ module ibex_cs_registers import cheri_pkg::*;  #(
   end
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/ibex_id_stage.sv b/rtl/ibex_id_stage.sv
index 24f27a5..3d6a5b4 100644
--- a/rtl/ibex_id_stage.sv
+++ b/rtl/ibex_id_stage.sv
@@ -230,7 +230,7 @@ module ibex_id_stage import cheri_pkg::*; #(
   logic        wfi_insn_dec;
 
   logic        wb_exception;
-  logic        id_exception;
+  logic        unused_id_exception;
   logic        id_exception_nc;
 
   logic        branch_in_dec;
@@ -655,7 +655,7 @@ module ibex_id_stage import cheri_pkg::*; #(
     .store_err_i    (lsu_store_err_i),
     .lsu_err_is_cheri_i (lsu_err_is_cheri_i),
     .wb_exception_o (wb_exception),
-    .id_exception_o (id_exception),
+    .id_exception_o (unused_id_exception),
     .id_exception_nc_o (id_exception_nc),
 
     // jump/branch control
@@ -1169,7 +1169,6 @@ module ibex_id_stage import cheri_pkg::*; #(
     logic unused_outstanding_store_wb;
     logic unused_wb_exception;
     logic [31:0] unused_rf_wdata_fwd_wb;
-    logic unused_id_exception;
 
     assign unused_data_req_done_ex     = lsu_req_done_i;
     assign unused_rf_waddr_wb          = rf_waddr_wb_i;
@@ -1178,7 +1177,6 @@ module ibex_id_stage import cheri_pkg::*; #(
     assign unused_outstanding_store_wb = outstanding_store_wb_i;
     assign unused_wb_exception         = wb_exception;
     assign unused_rf_wdata_fwd_wb      = rf_wdata_fwd_wb_i;
-    assign unused_id_exception         = id_exception;
 
     assign instr_type_wb_o = WB_INSTR_OTHER;
     assign stall_wb        = 1'b0;
diff --git a/rtl/ibex_if_stage.sv b/rtl/ibex_if_stage.sv
index d3b4862..4f0e31f 100644
--- a/rtl/ibex_if_stage.sv
+++ b/rtl/ibex_if_stage.sv
@@ -16,6 +16,8 @@
 
 `include "prim_assert.sv"
 
+/* verilator lint_off UNUSED */
+
 module ibex_if_stage import ibex_pkg::*; import cheri_pkg::*; #(
   parameter int unsigned DmHaltAddr        = 32'h1A110800,
   parameter int unsigned DmExceptionAddr   = 32'h1A110808,
@@ -355,11 +357,11 @@ module ibex_if_stage import ibex_pkg::*; import cheri_pkg::*; #(
 
   // let's only check this in pure-cap mode. otherwise jalr/ret gives so much headache
   // pre-calculate headroom to improve memory read timing
-  logic [2:0]  instr_len;
+  logic [2:0]  unused_instr_len;
   logic [32:0] instr_hdrm;
   logic        hdrm_ge4, hdrm_ge2, hdrm_ok;
 
-  assign instr_len  = (fetch_valid & ~fetch_err & instr_is_compressed) ? 2 : 4;
+  assign unused_instr_len  = (fetch_valid & ~fetch_err & instr_is_compressed) ? 2 : 4;
   assign instr_hdrm = pcc_cap_i.top33 - if_instr_addr;
   assign hdrm_ge4   = (instr_hdrm >= 4);
   assign hdrm_ge2   = (instr_hdrm >= 2);
@@ -791,3 +793,5 @@ module ibex_if_stage import ibex_pkg::*; import cheri_pkg::*; #(
   `ASSERT(IbexInstrAddrUnaligned, instr_req_o |-> (instr_addr_o[1:0] == 2'b00))
 
 endmodule
+
+/* verilator lint_on UNUSED */
diff --git a/rtl/ibex_lockstep.sv b/rtl/ibex_lockstep.sv
index 9522b4b..8211a7b 100644
--- a/rtl/ibex_lockstep.sv
+++ b/rtl/ibex_lockstep.sv
@@ -571,6 +571,7 @@ module ibex_lockstep import ibex_pkg::*; import cheri_pkg::*; #(
     .tsmap_rdata_i       (shadow_inputs_q[0].tsmap_rdata),
     .mmreg_corein_i      (shadow_inputs_q[0].mmreg_corein),
     .mmreg_coreout_o     (shadow_outputs_d.mmreg_coreout),  
+    .cheri_fatal_err_o   (), // TODO actually check this output
 
     .ic_tag_req_o        (shadow_outputs_d.ic_tag_req),
     .ic_tag_write_o      (shadow_outputs_d.ic_tag_write),
diff --git a/rtl/ibexc_top.sv b/rtl/ibexc_top.sv
index 2c493b4..2c9e660 100644
--- a/rtl/ibexc_top.sv
+++ b/rtl/ibexc_top.sv
@@ -13,11 +13,12 @@
 
 `include "prim_assert.sv"
 
+/* verilator lint_off UNUSED */
 
 /**
  * Top level module of the ibex RISC-V core
  */
-module ibex_top import ibex_pkg::*; import cheri_pkg::*; #(
+module ibexc_top import ibex_pkg::*; import cheri_pkg::*; #(
   parameter int unsigned DmHaltAddr       = 32'h1A110800,
   parameter int unsigned DmExceptionAddr  = 32'h1A110808,
   parameter bit          DbgTriggerEn     = 1'b1,
@@ -373,7 +374,7 @@ module ibex_top import ibex_pkg::*; import cheri_pkg::*; #(
 
     .fetch_enable_i(fetch_enable_buf),
     .alert_minor_o(alert_minor_o),
-    .alert_major_o(alert_major_o),
+    .alert_major_o(alert_major_internal_o),
     .icache_inval_o(),
     .core_busy_o   (core_busy_d),
     .ic_scr_key_valid_i (1'b0),
@@ -390,6 +391,7 @@ module ibex_top import ibex_pkg::*; import cheri_pkg::*; #(
   );
 
   assign data_wdata_intg_o = 7'h0;
+  assign alert_major_bus_o = 1'b0;
 
   /////////////////////////////////
   // Register file Instantiation //
@@ -454,4 +456,8 @@ module ibex_top import ibex_pkg::*; import cheri_pkg::*; #(
     );
   end
 
+  assign scramble_req_o = 0;
+
 endmodule
+
+/* verilator lint_on UNUSED */
